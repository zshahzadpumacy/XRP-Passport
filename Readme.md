# XRP Passport
For our solution we have followed the DID format of W3C standard which is:
<pre>"did:" method-name ":" method-specific-idstring</pre>
So our DID looks something like this:
<pre>did:xrpl:devnet:r9ZzpADNRATj1r6sHYANB5Rv63PoLoHSz</pre>
The specific components are:
- **method-name**: Method-name is **xrpl** which shows that this did belongs to XRP ledger.
- **network-id**: Network-id mentions on which XRPL network this ID is running on, which in our case is **devnet**.
- **xrpl-specific-idstring**: Xrpl-Specific-Idstring is basically XRPL address which is **r9ZzpADNRATj1r6sHYANB5Rv63PoLoHSz**

This repository contains files of ongoing work on XRP Passport project:
- DID Document Creation.
- DID object creation.
- Account Information.
- Extracting Public Key.

### DID Document Creation
A DID document (Decentralized Identifier Document) based on the W3C standard is gernerated. This document is like a profile that contains a cryptographic public key that the DID subject can use to authenticate itself and prove its association with the DID and the authenticity of stored data.
### DID Object Creation
A DID object is created after the scuuessfull implementation of DIDset transaction. For this transaction we derived a key pair from a secret to obtain the signingPubKey, one of the required parameters for DIDset transactions. Another requirement is a URI. To meet this, we created a DID JSON Document as mentioned above, uploaded it to the IPFS platform, and received a URL in return, which we converted into a hexadecimal string before using it. After successfully executing the DIDset transaction and creation of a DID object on the XRP devnet we also successfully tested DIDDelete transaction which we verified from XRP devnet explorer.
### Account Information
By using account_objects command we were able to view the changes that were made by our transactions such as the creation of the DID object, its deletion and reserve requirments. It helped us in testing and verifying our transactions.
### Keys Generation
This file makes it easy to get different information related to xrp wallet such as Public key, Private key and XRP address which can then be used for different purposes such as Private key is used to generate signature for verification.
### Signature Creation
At the moment we are using a default data which is later hashed using sha256. Using this hash a signature is created from it by using the private key of the account. This signature is basically used for verification and authentication.

Files such as resolver.js, xrpl-did-resolver.js and verify_signature.cjs work together to perform Identity verification for signing up on any Dapp on XRPL that accepts DID verifiction. revolver.js acts like the main file and other two are connected with it.

## Accomplishments
We are satisfied with our progress as our implementation phase is almost completed. One of the major tasks was the creation of a robust pipeline for DID verification. We have developed multiple scripts that seamlessly integrate to ensure smooth verification.
In this process, the user only needs to provide their DID string along with a signature signed using their private key. Notably, the signature itself is generated by the Redimi team to avoid making things complex for users.
Using the provided DID string, our script retrieves the associated DID object from the XRPL. This enables us to access and resolve the corresponding DID document, which is stored securely on third-party storage. From this document, we extract the public key, which is then used to verify the userâ€™s signature against it. At the end the verifier will get a response if the verification was successful or not.

## Challenges
During the implementation phase, we encountered some challenges that required adaptation, such as we were using IPFS as third-party storage for the DID document; however, we faced the issue where if the DID Document file was not pinned, we would not be able to fetch it or the connection would time out.. To avoid this, we shifted to Pinata, which is more reliable and has better accessibility.
Another significant challenge arose during the development of the resolver. This component was not originally included in our project plan, which meant we had to allocate additional time and effort for its implementation. However, we were able to build on the great work from our mentor, Mayukha Vadari, which was a big help and enabled us to complete the resolver.

