# XRP Passport
For our solution we have followed the DID format of W3C standard which is:
<pre>"did:" method-name ":" method-specific-idstring</pre>
So our DID looks something like this:
<pre>did:xrpl:devnet:r9ZzpADNRATj1r6sHYANB5Rv63PoLoHSz</pre>
The specific components are:
- **method-name**: Method-name is **xrpl** which shows that this did belongs to XRP ledger.
- **network-id**: Network-id mentions on which XRPL network this ID is running on, which in our case is **devnet**.
- **xrpl-specific-idstring**: Xrpl-Specific-Idstring is basically XRPL address which is **r9ZzpADNRATj1r6sHYANB5Rv63PoLoHSz**

This repository contains files of ongoing work on XRP Passport project:
- DID Document Creation.
- DID object creation.
- Account Information.
- Extracting Public Key.

### DID Document Creation
A DID document (Decentralized Identifier Document) based on the W3C standard is gernerated. This document is like a profile that contains a cryptographic public key that the DID subject can use to authenticate itself and prove its association with the DID and the authenticity of stored data.
### DID Object Creation
A DID object is created after the scuuessfull implementation of DIDset transaction. For this transaction we derived a key pair from a secret to obtain the signingPubKey, one of the required parameters for DIDset transactions. Another requirement is a URI. To meet this, we created a DID JSON Document as mentioned above, uploaded it to the IPFS platform, and received a URL in return, which we converted into a hexadecimal string before using it. After successfully executing the DIDset transaction and creation of a DID object on the XRP devnet we also successfully tested DIDDelete transaction which we verified from XRP devnet explorer.
### Account Information
By using account_objects command we were able to view the changes that were made by our transactions such as the creation of the DID object, its deletion and reserve requirments. It helped us in testing and verifying our transactions.
### Keys Generation
This file makes it easy to get different information related to xrp wallet such as Public key, Private key and XRP address which can then be used for different purposes such as Private key is used to generate signature for verification.
### Signature Creation
At the moment we are using a default data which is later hashed using sha256. Using this hash a signature is created from it by using the private key of the account. This signature is basically used for verification and authentication.

Files such as resolver.js, xrpl-did-resolver.js and verify_signature.cjs work together to perform Identity verification for signing up on any Dapp on XRPL that accepts DID verifiction. revolver.js acts like the main file and other two are connected with it.

## Accomplishments
We are satisfied with our progress as our implementation phase is almost completed. One of the major tasks was the creation of a robust pipeline for DID verification. We have developed multiple scripts that seamlessly integrate to ensure smooth verification.
In this process, the user only needs to provide their DID string along with a signature signed using their private key. Notably, the signature itself is generated by the Redimi team to avoid making things complex for users.
Using the provided DID string, our script retrieves the associated DID object from the XRPL. This enables us to access and resolve the corresponding DID document, which is stored securely on third-party storage. From this document, we extract the public key, which is then used to verify the user‚Äôs signature against it. At the end the verifier will get a response if the verification was successful or not.

## Challenges
During the implementation phase, we encountered some challenges that required adaptation, such as we were using IPFS as third-party storage for the DID document; however, we faced the issue where if the DID Document file was not pinned, we would not be able to fetch it or the connection would time out.. To avoid this, we shifted to Pinata, which is more reliable and has better accessibility.
Another significant challenge arose during the development of the resolver. This component was not originally included in our project plan, which meant we had to allocate additional time and effort for its implementation. However, we were able to build on the great work from our mentor, Mayukha Vadari, which was a big help and enabled us to complete the resolver.

# üìã SUMSUB KYC + Verifiable Credentials Pipeline

## üéØ **Pipeline Overview**
This codebase implements a complete KYC verification system using Sumsub for identity verification, followed by automatic creation and storage of Verifiable Credentials (VCs) on the XRPL blockchain and IPFS.

---

## üìÅ **Sumsub File Structure**

### **1. FRONTEND INITIATION**
**`views/kyc.ejs`** 
- **Purpose**: Main KYC verification interface
- **Function**: Renders Sumsub SDK integration for user identity verification
- **Key Features**: 
  - Loads Sumsub WebSDK for identity checks
  - Handles SDK initialization and error handling
  - Provides user interface for document upload and verification


**`public/sdk/sns-websdk-builder.js`** 
- **Purpose**: Local fallback for Sumsub SDK
- **Function**: Serves as backup when CDN is unavailable


### **2. BACKEND SERVER & ROUTING**
**`server/index.js`** 
- **Purpose**: Main Express server handling all routes and webhook processing
- **Key Functions**:
  - `/kyc` - Serves KYC verification page
  - `/refreshToken` - Refreshes Sumsub SDK tokens
  - `/sumsub/webhook` - Processes Sumsub webhook notifications
  - `/debug` - Debug endpoint for environment variables


### **3. VERIFIABLE CREDENTIAL CREATION**
**`server/verifiable-credential-integrated.js`** 
- **Purpose**: Core VC creation and management system
- **Key Functions**:
  - `initializeWithSeed()` - Sets up DID from XRPL seed
  - `createKYCVerifiableCredential()` - Creates VC from KYC data
  - `signCredential()` - Cryptographically signs VCs
  - `uploadCredentialToIPFS()` - Stores VCs on IPFS
  - `createDIDTransaction()` - Records DID on XRPL


**`server/pinata-uploader.js`** 
- **Purpose**: IPFS upload functionality via Pinata
- **Key Functions**:
  - `uploadToIPFS()` - Uploads JSON data to IPFS
  - `getIPFSHash()` - Retrieves IPFS hash from response


**`server/xrpl-did-transaction.js`** 
- **Purpose**: XRPL blockchain interaction for DID operations
- **Key Functions**:
  - `createDIDTransaction()` - Creates DID on XRPL
  - `getDIDObject()` - Retrieves DID from XRPL
  - `extractAccountFromDID()` - Parses XRPL DIDs


### **4. VERIFICATION & RETRIEVAL**
**`did-verification/did-vc-fetcher.js`** 
- **Purpose**: Retrieves and validates VCs from XRPL/IPFS
- **Key Functions**:
  - `getVCFromDID()` - Fetches VC using DID
  - `getVCWithDIDAndKey()` - Authenticated VC retrieval
  - `convertIPFSUriToPinataUrl()` - IPFS URI conversion


**`did-verification/Verification.js`** 
- **Purpose**: VC verification utilities
- **Key Functions**: VC validation and verification logic


### **5. STORAGE & OUTPUT**
**`credentials`** 
- **Purpose**: Sample stored credential
- **Content**: Example VC in JSON format

---

## üîÑ **Pipeline Flow**

### **Phase 1: User Verification**
1. User visits `/kyc` ‚Üí `views/kyc.ejs` renders
2. Sumsub SDK loads ‚Üí User completes identity verification
3. Sumsub sends webhook to `/sumsub/webhook` ‚Üí `server/index.js` processes

### **Phase 2: VC Creation**
4. Webhook triggers ‚Üí `server/verifiable-credential-integrated.js` initializes
5. System prompts for XRPL seed ‚Üí Creates DID and wallet
6. VC created from KYC data ‚Üí Signed cryptographically
7. VC uploaded to IPFS ‚Üí `server/pinata-uploader.js` handles
8. DID transaction created on XRPL ‚Üí `server/xrpl-did-transaction.js` handles

### **Phase 3: Verification & Retrieval**
9. VC stored on IPFS with DID reference on XRPL
10. `did-verification/did-vc-fetcher.js` can retrieve VCs
11. VCs can be verified using DID and private key


This pipeline creates a complete, decentralized identity verification system with verifiable credentials stored on blockchain and IPFS. 

